"""
In this assignment you should fit a model function of your choice to data 
that you sample from a given function. 

The sampled data is very noisy so you should minimize the mean least squares 
between the model you fit and the data points you sample.  

During the testing of this assignment running time will be constrained. You
receive the maximal running time as an argument for the fitting method. You 
must make sure that the fitting function returns at most 5 seconds after the 
allowed running time elapses. If you take an iterative approach and know that 
your iterations may take more than 1-2 seconds break out of any optimization 
loops you have ahead of time.

Note: You are NOT allowed to use any numeric optimization libraries and tools 
for solving this assignment. 

"""

import numpy as np
import time
import random


class Assignment4:
    def __init__(self):
        """
        Here goes any one time calculation that need to be made before 
        solving the assignment for specific functions. 
        """
        pass

    def fit(self, f: callable, a: float, b: float, d: int, maxtime: float) -> callable:
        """
        is a function that takes in a callable function f, a float a and b representing the range of the x values to
        sample data from, an integer d representing the degree of the polynomial to fit the data to, and a float
        maxtime representing the maximum allowed runtime for the function. It returns a callable function that
        represents the polynomial of degree d that best fits the data points generated by sampling f in the range [a,
        b].
        :param f:a callable function f
        :param a: start of the range of  x values
        :param b: end of the range of  x values
        :param d: degree of polynomial
        :param
        maxtime: a limoit for the  execution time of the function
        :return: function that has the coefficients of that multiplication as its parameters.
        """

        start_time = time.time()
        x_values = np.linspace(a, b, d * d)
        y_values = [f(x) for x in x_values]
        if len(y_values) == 0:
            return lambda x: 0  # return a zero polynomial if y_values is empty
        X = np.array([x_values ** k for k in range(d + 1)]).T
        try:
            beta = np.linalg.inv(X.T.dot(X)).dot(X.T).dot(y_values)
        except np.linalg.LinAlgError:
            return lambda x: 0  # return a zero polynomial if the matrix is singular

        def polynomial(x):
            return sum([beta[k] * x ** k for k in range(d + 1)])

        if time.time() - start_time > maxtime:
            raise Exception("Fit took longer than allowed maximum time")

        return polynomial

##########################################################################


import unittest
from sampleFunctions import *
from tqdm import tqdm


class TestAssignment4(unittest.TestCase):

    def test_return(self):
        f = NOISY(0.01)(poly(1, 1, 1))
        ass4 = Assignment4()
        T = time.time()
        shape = ass4.fit(f=f, a=0, b=1, d=10, maxtime=5)
        T = time.time() - T
        self.assertLessEqual(T, 5)

    # def test_delay(self):
    # f = DELAYED(7)(NOISY(0.01)(poly(1,1,1)))
    #
    # ass4 = Assignment4()
    # T = time.time()
    # shape = ass4.fit(f=f, a=0, b=1, d=10, maxtime=5)
    # T = time.time() - T
    # self.assertGreaterEqual(T, 5)

    def test_err(self):
        f = poly(1, 1, 1)
        nf = NOISY(1)(f)
        ass4 = Assignment4()
        T = time.time()
        ff = ass4.fit(f=nf, a=0, b=1, d=10, maxtime=5)
        T = time.time() - T
        mse = 0
        for x in np.linspace(0, 1, 1000):
            self.assertNotEqual(f(x), nf(x))
            mse += (f(x) - ff(x)) ** 2
        mse = mse / 1000
        print(mse)
